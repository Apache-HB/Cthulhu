#pragma once
/* autogenerated source, do not edit */

#include "core/where.h"
#include <gmp.h>
#include "cthulhu/tree/ops.h"
typedef struct vector_t vector_t;
typedef struct node_t node_t;
typedef struct scan_t scan_t;
typedef struct pl0x_ast_t pl0x_ast_t;
typedef enum pl0x_kind_t {
	ePl0xIdent,
	ePl0xDigit,
	ePl0xOdd,
	ePl0xUnary,
	ePl0xBinary,
	ePl0xCompare,
	ePl0xAssign,
	ePl0xBranch,
	ePl0xStmts,
	ePl0xProcedure,
	ePl0xValue,
	ePl0xImport,
	ePl0xModule,
	ePl0xCount
} pl0x_kind_t;
typedef struct pl0x_ident_t {
	const char *ident;
} pl0x_ident_t;
typedef struct pl0x_digit_t {
	mpz_t digit;
} pl0x_digit_t;
typedef struct pl0x_odd_t {
	pl0x_ast_t *expr;
} pl0x_odd_t;
typedef struct pl0x_unary_t {
	unary_t unary;
	pl0x_ast_t *operand;
} pl0x_unary_t;
typedef struct pl0x_binary_t {
	binary_t binary;
} pl0x_binary_t;
typedef struct pl0x_compare_t {
	compare_t compare;
} pl0x_compare_t;
typedef struct pl0x_assign_t {
	const char *dst;
	pl0x_ast_t *src;
} pl0x_assign_t;
typedef struct pl0x_branch_t {
	pl0x_ast_t *cond;
	pl0x_ast_t *then;
} pl0x_branch_t;
typedef struct pl0x_stmts_t {
	vector_t *stmts;
} pl0x_stmts_t;
typedef struct pl0x_procedure_t {
	vector_t *locals;
	vector_t *body;
} pl0x_procedure_t;
typedef struct pl0x_value_t {
	pl0x_ast_t *value;
} pl0x_value_t;
typedef struct pl0x_import_t {
	vector_t *path;
} pl0x_import_t;
typedef struct pl0x_module_t {
	vector_t *consts;
	vector_t *globals;
	vector_t *procedures;
	pl0x_ast_t *entry;
	vector_t *modspec;
	vector_t *imports;
} pl0x_module_t;
struct pl0x_ast_t {
	pl0x_kind_t kind;
	const node_t *node;

	union {
		/* ePl0xIdent */
		pl0x_ident_t ident;
		/* ePl0xDigit */
		pl0x_digit_t digit;
		/* ePl0xOdd */
		pl0x_odd_t odd;
		/* ePl0xUnary */
		pl0x_unary_t unary;
		/* ePl0xBinary */
		pl0x_binary_t binary;
		/* ePl0xCompare */
		pl0x_compare_t compare;
		/* ePl0xAssign */
		pl0x_assign_t assign;
		/* ePl0xBranch */
		pl0x_branch_t branch;
		/* ePl0xStmts */
		pl0x_stmts_t stmts;
		/* ePl0xProcedure */
		pl0x_procedure_t procedure;
		/* ePl0xValue */
		pl0x_value_t value;
		/* ePl0xImport */
		pl0x_import_t import;
		/* ePl0xModule */
		pl0x_module_t module;
	};
};
pl0x_ast_t *pl0x_ident(scan_t *scan, where_t where, const char *ident);
pl0x_ast_t *pl0x_digit(scan_t *scan, where_t where, mpz_t digit);
pl0x_ast_t *pl0x_odd(scan_t *scan, where_t where, pl0x_ast_t *expr);
pl0x_ast_t *pl0x_unary(scan_t *scan, where_t where, unary_t unary, pl0x_ast_t *operand);
pl0x_ast_t *pl0x_binary(scan_t *scan, where_t where, binary_t binary);
pl0x_ast_t *pl0x_compare(scan_t *scan, where_t where, compare_t compare);
pl0x_ast_t *pl0x_assign(scan_t *scan, where_t where, const char *dst, pl0x_ast_t *src);
pl0x_ast_t *pl0x_branch(scan_t *scan, where_t where, pl0x_ast_t *cond, pl0x_ast_t *then);
pl0x_ast_t *pl0x_stmts(scan_t *scan, where_t where, vector_t *stmts);
pl0x_ast_t *pl0x_procedure(scan_t *scan, where_t where, vector_t *locals, vector_t *body);
pl0x_ast_t *pl0x_value(scan_t *scan, where_t where, pl0x_ast_t *value);
pl0x_ast_t *pl0x_import(scan_t *scan, where_t where, vector_t *path);
pl0x_ast_t *pl0x_module(scan_t *scan, where_t where, vector_t *consts, vector_t *globals, vector_t *procedures, pl0x_ast_t *entry, vector_t *modspec, vector_t *imports);
size_t pl0x_ast_hash(const pl0x_ast_t *ast);
