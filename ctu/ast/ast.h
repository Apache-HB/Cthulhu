#pragma once

#include <stdint.h>

#include "scanner.h"
#include "type.h"

typedef struct {
    struct node_t **data;
    size_t len, size;
} nodes_t;

typedef enum {
    /**
     * expressions
     */
    AST_DIGIT,
    AST_BOOL,
    AST_UNARY,
    AST_BINARY,
    AST_CALL,
    AST_CAST,

    /**
     * statements
     */
    AST_STMTS,
    AST_RETURN,
    AST_BRANCH,

    /**
     * declarations
     */
    AST_DECL_FUNC,
    AST_DECL_VAR,
    AST_DECL_PARAM,

    /**
     * types
     */
    AST_SYMBOL,
    AST_PTR,

    /**
     * implementation details
     */
    AST_TYPE
} ast_t;

typedef enum {
    UNARY_ABS, /* +expr */
    UNARY_NEG, /* -expr */

    UNARY_REF, /* &expr */
    UNARY_DEREF, /* *expr */

    UNARY_TRY, /* expr? */
} unary_t;

typedef enum {
    BINARY_ADD, /* expr + expr */
    BINARY_SUB, /* expr - expr */
    BINARY_MUL, /* expr * expr */
    BINARY_DIV, /* expr / expr */
    BINARY_REM, /* expr % expr */

    BINARY_LT, /* expr < expr */
    BINARY_LTE, /* expr <= expr */
    BINARY_GT, /* expr > expr */
    BINARY_GTE, /* expr >= expr */

    BINARY_EQ, /* expr == expr */
    BINARY_NEQ, /* expr != expr */
} binary_t;

/**
 * is any binary math operation
 */
bool is_math_op(binary_t op);

/**
 * is any binary comparison operator, not including equality
 */
bool is_comparison_op(binary_t op);

/**
 * is any binary equality operator
 */
bool is_equality_op(binary_t op);

#define NOT_LOCAL SIZE_MAX

/**
 * we need string interning at some point
 */
typedef struct node_t {
    /**
     * the type of this node 
     */
    ast_t kind;

    /**
     * the scanner that produced this node
     */
    scanner_t *scanner;

    /**
     * where in the scanner this node came from
     */
    where_t where;

    /**
     * was this node generated by user input or not
     */
    bool implicit:1;

    /**
     * the type of this nodes expression in its current context
     */
    type_t *typeof;

    union {
        struct {
            /* AST_SYMBOL */
            char *ident;
        };

        /* AST_DIGIT */
        uint64_t digit;

        /* AST_BOOL */
        bool boolean;

        /* AST_STMTS */
        nodes_t *stmts;

        /* AST_PTR */
        struct node_t *ptr;

        struct {
            /* AST_UNARY */
            unary_t unary;

            /* AST_RETURN */
            struct node_t *expr;

            union {
                /* AST_CAST */
                struct node_t *cast;

                /* AST_CALL */
                nodes_t *args;
            };
        };

        /* AST_BINARY */
        struct {
            binary_t binary;
            struct node_t *lhs;
            struct node_t *rhs;
        };

        /* AST_BRANCH */
        struct {
            struct node_t *cond;
            struct node_t *branch;

            struct node_t *next;
        };

        /* AST_DECL */
        struct {
            union {
                /**
                 * all declarations have names
                 */
                char *name;

                /* AST_TYPE */
                const char *nameof;
            };

            /* own local index, or NOT_LOCAL if its not local */
            size_t local;

            union {
                /* AST_DECL_FUNC */
                struct {
                    nodes_t *params;
                    struct node_t *result;
                    struct node_t *body;

                    /* total number of local variables */
                    size_t locals;
                };

                /* AST_DECL_VAR */
                struct {
                    /* AST_DECL_PARAM */
                    struct node_t *type;
                    struct node_t *init;
                };
            };
        };
    };
} node_t;

/**
 * query information
 */

/**
 * get the name of a declaration node
 * do not call on something that isnt a declaration
 */
const char *get_decl_name(node_t *node);

/**
 * get the name of a symbol
 * do not call on something that isnt a symbol
 */
const char *get_symbol_name(node_t *node);

/**
 * get the name of a resolved type
 * do not call with symbols
 */
const char *get_resolved_name(node_t *node);

/**
 * get the type of a node
 * returns an unresolved type if the type hasnt been resolved
 */
type_t *get_type(node_t *node);

/**
 * get the type of a node or NULL
 */
type_t *raw_type(node_t *node);

/**
 * get all statements in a list
 */
nodes_t *get_stmts(node_t *node);

/**
 * is this name the discarded name `$`
 */
bool is_discard_name(const char *name);

/**
 * list managment
 */

/**
 * create a new list starting with init
 * if init is null the list is empty
 */
nodes_t *ast_list(node_t *init);
nodes_t *ast_append(nodes_t *list, node_t *node);

/**
 * get a node from a list
 * must be in bounds
 */
node_t *ast_at(nodes_t *list, size_t idx);

/**
 * get a node of a specific kind from a list
 * asserts if the node is not of that kind
 */
node_t *ast_kind_at(nodes_t *list, size_t idx, ast_t kind);
size_t ast_len(nodes_t *list);

/**
 * modify nodes
 */

/**
 * mark a node as implicitly generated
 * used in the semantic state to generate implicit casts
 */
node_t *make_implicit(node_t *node);

/**
 * node creation
 */

node_t *ast_digit(scanner_t *scanner, where_t where, char *digit, int base);
node_t *ast_bool(scanner_t *scanner, where_t where, bool boolean);

node_t *ast_unary(scanner_t *scanner, where_t where, unary_t unary, node_t *expr);
node_t *ast_binary(scanner_t *scanner, where_t where, binary_t binary, node_t *lhs, node_t *rhs);
node_t *ast_call(scanner_t *scanner, where_t where, node_t *body, nodes_t *args);
node_t *ast_cast(scanner_t *scanner, where_t where, node_t *expr, node_t *cast);

node_t *ast_stmts(scanner_t *scanner, where_t where, nodes_t *stmts);
node_t *ast_return(scanner_t *scanner, where_t where, node_t *expr);
node_t *ast_branch(scanner_t *scanner, where_t where, node_t *cond, node_t *branch);
node_t *add_branch(node_t *branch, node_t *next);

node_t *ast_symbol(scanner_t *scanner, where_t where, char *text);
node_t *ast_pointer(scanner_t *scanner, where_t where, node_t *ptr);

node_t *ast_decl_func(
    scanner_t *scanner, where_t where, 
    char *name, nodes_t *params,
    node_t *result, node_t *body
);
node_t *ast_decl_param(scanner_t *scanner, where_t where, char *name, node_t *type);
node_t *ast_decl_var(scanner_t *scanner, where_t where, char *name, node_t *init);

/**
 * create a builtin type
 */
node_t *ast_type(const char *name);

/**
 * free a list of nodes
 * if free_items is true then also free all the nodes
 * in the list
 */
void free_ast_list(nodes_t *list, bool free_items);