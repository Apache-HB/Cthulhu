#pragma once

#include "core/text.h"
#include "cthulhu/tree/ops.h"
#include "cthulhu/tree/context.h"

#include <stdbool.h>
#include <gmp.h>

typedef struct logger_t logger_t;

typedef struct vector_t vector_t;
typedef struct map_t map_t;
typedef struct node_t node_t;

typedef struct tree_t tree_t;
typedef struct tree_cookie_t tree_cookie_t;
typedef struct diagnostic_t diagnostic_t;

BEGIN_API

/// @defgroup tree Tree intermediate form
/// @ingroup runtime
/// @brief Tree intermediate form generated by language drivers
/// @{

typedef void (*resolve_t)(tree_t *sema, tree_t *self, void *user);
typedef void (*resolve_type_t)(tree_t *sema, tree_t *self, void *user);

typedef enum sema_tags_t {
    eSemaValues,
    eSemaTypes,
    eSemaProcs,
    eSemaModules,

    eSemaTotal
} sema_tags_t;

typedef struct tree_attribs_t {
    tree_link_t link; ///< the link type of the declaration
    visibility_t visibility; ///< the visibility of the declaration

    const char *mangle; ///< override the mangle of the declaration
    const char *section; ///< override the section of the declaration
    const char *deprecated; ///< the reason for deprecation, or NULL if not deprecated
} tree_attribs_t;

typedef struct tree_cookie_t {
    logger_t *reports;
    vector_t *stack;
} tree_cookie_t;

typedef struct tree_resolve_info_t {
    tree_t *sema;
    void *user;

    resolve_t fn_resolve;
    resolve_type_t fn_resolve_type;
} tree_resolve_info_t;

typedef enum tree_kind_t {
#define TREE_KIND(ID, NAME, TAGS) ID,
#include "cthulhu/tree/tree.def"

    eTreeTotal
} tree_kind_t;

typedef struct tree_t {
    tree_kind_t kind;
    const node_t *node;
    const tree_t *type;

    union {
        /* eTreeDigit */
        mpz_t digit_value;

        /* eTreeBool */
        bool bool_value;

        /* eTreeString */
        text_view_t string_value;

        /* eTreeExprLoad */
        tree_t *load;

        /* eTreeExprRef */
        tree_t *expr;

        /* eTreeExprCast */
        tree_t *cast;

        /* eTreeExprUnary */
        struct {
            unary_t unary;
            tree_t *operand;
        };

        /* eTreeExprBinary|eTreeExprCompare */
        struct {
            union {
                binary_t binary;
                compare_t compare;
            };

            tree_t *lhs;
            tree_t *rhs;
        };

        /* eTreeExprCall */
        struct {
            const tree_t *callee;
            vector_t *args;
        };

        /* eTreeError */
        struct {
            const diagnostic_t *diagnostic;
            const char *message;
        };

        /* eTreeStmtBlock */
        vector_t *stmts;

        /* eTreeStmtReturn */
        const tree_t *value;

        /* eTreeStmtAssign */
        struct {
            tree_t *dst;
            tree_t *src;
        };

        /* eTreeStmtLoop|eTreeStmtBranch */
        struct {
            tree_t *cond;
            tree_t *then;
            tree_t *other;
        };

        struct {
            tree_t *object;
            struct {
                /* eTreeExprOffset */
                tree_t *offset;

                /* eTreeExprField */
                tree_t *field;
            };
        };

        /* eTreeStmtJump */
        struct {
            tree_t *label;
            tree_jump_t jump;
        };

        /* any declaration */
        struct {
            const char *name; ///< the name of the declaration
            const tree_attribs_t *attrib; ///< the attributes of the declaration
            const tree_resolve_info_t *resolve; ///< the resolve configuration of the declaration, NULL if resolved
            quals_t quals;

            union {
                /* eTreeTypePointer|eTreeTypeReference|eTreeTypeArray */
                struct {
                    const tree_t *ptr;
                    const tree_t *len;
                    size_t length;
                };

                /* eTreeTypeDigit */
                struct {
                    digit_t digit;
                    sign_t sign;
                };

                /* eTreeTypeStruct */
                vector_t *fields;

                /* eTreeDeclEnum */
                struct {
                    const tree_t *underlying;
                    vector_t *cases;
                    tree_t *default_case;
                };

                /* eTreeDeclCase */
                tree_t *case_value;

                struct {
                    vector_t *params;

                    union {
                        /* eTreeDeclFunction */
                        struct {
                            vector_t *locals;
                            tree_t *body;
                        };

                        /* eTreeTypeClosure */
                        struct {
                            const tree_t *return_type;
                            arity_t arity;
                        };
                    };
                };

                /* eTreeDeclGlobal|eTreeDeclLocal */
                struct {
                    tree_storage_t storage;

                    tree_t *initial;
                };

                /* eTreeDeclModule */
                struct {
                    arena_t *arena;
                    tree_t *parent;
                    tree_cookie_t *cookie;

                    logger_t *reports;
                    vector_t *tags; ///< vector_t<map_t<const char*, void*>*>
                };
            };
        };
    };
} tree_t;

///
/// tree error handling
///

CT_TREE_API tree_t *tree_error(const node_t *node, const diagnostic_t *diagnostic, const char *message, ...);
CT_TREE_API tree_t *tree_pick_error(const node_t *node, const tree_t *lhs, const tree_t *rhs);
CT_TREE_API tree_t *tree_raise(const node_t *node, logger_t *reports, const diagnostic_t *diagnostic, const char *message, ...);
CT_TREE_API void tree_report(logger_t *reports, const tree_t *error);

///
/// tree type interface
///

/**
 * @brief create an empty type, this is a type that has no values and can never be created in a well defined program
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @return an empty type
 */
CT_TREE_API tree_t *tree_type_empty(const node_t *node, const char *name);

/**
 * @brief create a unit type, this is a type that has only one value. equivilent to void
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @return a unit type
 */
CT_TREE_API tree_t *tree_type_unit(const node_t *node, const char *name);

/**
 * @brief create a bool type, this is a type that has only two values, true and false
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @return a bool type
 */
CT_TREE_API tree_t *tree_type_bool(const node_t *node, const char *name);

/**
 * @brief create an opaque pointer type
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @return tree_t*
 */
CT_TREE_API tree_t *tree_type_opaque(const node_t *node, const char *name);

/**
 * @brief create a digit type
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @param digit the width of the digit
 * @param sign the sign of the digit
 * @return a digit type
 */
CT_TREE_API tree_t *tree_type_digit(const node_t *node, const char *name, digit_t digit, sign_t sign);

/**
 * @brief create a function pointer type
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @param result return type of the function
 * @param params the parameters of the function
 * @param arity does this function have variadic arguments
 * @return tree_t* the function pointer type
 */
CT_TREE_API tree_t *tree_type_closure(const node_t *node, const char *name, const tree_t *result, vector_t *params, arity_t arity);

/**
 * @brief create a pointer type
 *
 * @param node where this type was defined
 * @param name the name of the type
 * @param pointer the type that this pointer points to
 * @param length the optional length of the pointer
 * @return tree_t* the pointer type
 */
CT_TREE_API tree_t *tree_type_pointer(const node_t *node, const char *name, const tree_t *pointer, size_t length);

/**
 * @brief create a reference type
 *
 * @param node the location of the reference
 * @param name the name of the type
 * @param reference the type that this reference references
 * @return tree_t* the reference type
 */
CT_TREE_API tree_t *tree_type_reference(const node_t *node, const char *name, const tree_t *reference);

/// @brief create a new array type
///
/// @param node the location of the array
/// @param name the name of the type
/// @param array the element type of the array
/// @param length the length of the array
///
/// @return the array type
CT_TREE_API tree_t *tree_type_array(const node_t *node, const char *name, const tree_t *array, size_t length);

///
/// tree expr interface
///

CT_TREE_API tree_t *tree_expr_empty(const node_t *node, const tree_t *type);
CT_TREE_API tree_t *tree_expr_unit(const node_t *node, const tree_t *type);
CT_TREE_API tree_t *tree_expr_bool(const node_t *node, const tree_t *type, bool value);
CT_TREE_API tree_t *tree_expr_digit(const node_t *node, const tree_t *type, const mpz_t value);

/**
 * @brief create a string expression
 *
 * @param node a node to attach the expression to
 * @param type the type of the expression
 * @param value a null terminated string
 * @param length the length of the string not including the null terminator
 * @return tree_t*
 */
CT_TREE_API tree_t *tree_expr_string(const node_t *node, const tree_t *type, const char *value, size_t length);

CT_TREE_API tree_t *tree_expr_cast(const node_t *node, const tree_t *type, tree_t *expr);

/**
 * @brief load a value from a pointer or storage
 *
 * @param node the location of the load
 * @param expr the pointer or storage to load from
 * @return tree_t* the loaded value
 */
CT_TREE_API tree_t *tree_expr_load(const node_t *node, tree_t *expr);

/**
 * @brief create a reference to an object
 *
 * @param node the location of the reference
 * @param expr the object to reference
 * @return tree_t*
 */
CT_TREE_API tree_t *tree_expr_ref(const node_t *node, tree_t *expr);

/**
 * @brief create a reference to an object
 *
 * @param node the location of the reference
 * @param expr the object to reference
 * @return tree_t* the reference
 */
CT_TREE_API tree_t *tree_expr_address(const node_t *node, tree_t *expr);

CT_TREE_API tree_t *tree_expr_unary(const node_t *node, unary_t unary, tree_t *expr);
CT_TREE_API tree_t *tree_expr_binary(const node_t *node, const tree_t *type, binary_t binary, tree_t *lhs, tree_t *rhs);
CT_TREE_API tree_t *tree_expr_compare(const node_t *node, const tree_t *type, compare_t compare, tree_t *lhs, tree_t *rhs);

CT_TREE_API tree_t *tree_expr_field(const node_t *node, const tree_t *type, tree_t *object, tree_t *field);

CT_TREE_API tree_t *tree_expr_offset(const node_t *node, const tree_t *type, tree_t *object, tree_t *offset);

CT_TREE_API tree_t *tree_expr_call(const node_t *node, const tree_t *callee, vector_t *args);

///
/// tree statement interface
///

/**
 * @brief create a block statement
 *
 * @param node the location of the block statement
 * @param stmts the statements in the block
 * @return the block statement
 */
CT_TREE_API tree_t *tree_stmt_block(const node_t *node, vector_t *stmts);

/**
 * @brief create a return statement
 *
 * @note this is only valid in a function
 *
 * @param node the location of the return statement
 * @param value the value to return
 * @return the return statement
 */
CT_TREE_API tree_t *tree_stmt_return(const node_t *node, const tree_t *value);

CT_TREE_API tree_t *tree_stmt_assign(const node_t *node, tree_t *dst, tree_t *src);
CT_TREE_API tree_t *tree_stmt_loop(const node_t *node, tree_t *cond, tree_t *body, tree_t *other);
CT_TREE_API tree_t *tree_stmt_branch(const node_t *node, tree_t *cond, tree_t *then, tree_t *other);
CT_TREE_API tree_t *tree_stmt_jump(const node_t *node, tree_t *label, tree_jump_t jump);

///
/// tree decl interface
///

// delay the resolve of a declaration
CT_TREE_API tree_t *tree_resolve(tree_cookie_t *cookie, const tree_t *decl);
CT_TREE_API tree_t *tree_resolve_type(const tree_t *decl);

CT_TREE_API tree_t *tree_open_decl(const node_t *node, const char *name, tree_resolve_info_t resolve);
CT_TREE_API void tree_close_decl(tree_t *self, const tree_t *other);

///
/// global decls
///

CT_TREE_API tree_t *tree_decl_global(
    const node_t *node, const char *name,
    tree_storage_t storage, const tree_t *type, tree_t *initial
);

CT_TREE_API tree_t *tree_open_global(
    const node_t *node, const char *name,
    const tree_t *type, tree_resolve_info_t resolve
);

CT_TREE_API void tree_close_global(tree_t *self, tree_t *value);

///
/// function decls
///

CT_TREE_API tree_t *tree_decl_function(
    const node_t *node, const char *name, const tree_t *signature,
    vector_t *params, vector_t *locals, tree_t *body
);

CT_TREE_API tree_t *tree_open_function(
    const node_t *node, const char *name,
    const tree_t *signature, tree_resolve_info_t resolve
);

CT_TREE_API void tree_close_function(tree_t *self, tree_t *body);

///
/// struct decls
///

CT_TREE_API tree_t *tree_decl_struct(const node_t *node, const char *name, vector_t *fields);
CT_TREE_API tree_t *tree_open_struct(const node_t *node, const char *name, tree_resolve_info_t resolve);
CT_TREE_API void tree_close_struct(tree_t *self, vector_t *fields);

///
/// union decls
///

CT_TREE_API tree_t *tree_decl_union(const node_t *node, const char *name, vector_t *fields);
CT_TREE_API tree_t *tree_open_union(const node_t *node, const char *name, tree_resolve_info_t resolve);
CT_TREE_API void tree_close_union(tree_t *self, vector_t *fields);

///
/// enum decls
///

CT_TREE_API tree_t *tree_decl_enum(const node_t *node, const char *name, const tree_t *underlying, vector_t *fields, tree_t *default_case);
CT_TREE_API tree_t *tree_open_enum(const node_t *node, const char *name, tree_resolve_info_t resolve);
CT_TREE_API void tree_close_enum(tree_t *self, const tree_t *underlying, vector_t *fields, tree_t *default_case);

///
/// other decls
///

CT_TREE_API tree_t *tree_decl_param(const node_t *node, const char *name, const tree_t *type);
CT_TREE_API tree_t *tree_decl_field(const node_t *node, const char *name, const tree_t *type);
CT_TREE_API tree_t *tree_decl_local(const node_t *node, const char *name, tree_storage_t storage, const tree_t *type);
CT_TREE_API tree_t *tree_decl_case(const node_t *node, const char *name, tree_t *expr);

///
/// various helpers
///

CT_TREE_API void tree_add_local(tree_t *self, tree_t *decl);
CT_TREE_API void tree_add_param(tree_t *self, tree_t *decl);
CT_TREE_API void tree_add_enum(tree_t *self, tree_t *decl);
CT_TREE_API void tree_set_attrib(tree_t *self, const tree_attribs_t *attrib);
CT_TREE_API void tree_set_type(tree_t *self, const tree_t *type);

CT_TREE_API tree_t *tree_alias(const tree_t *tree, const char *name);

CT_TREE_API void tree_set_storage(tree_t *self, tree_storage_t storage);

///
/// tree sema interface
///

// only declarations placed in the tags eSemaValues, eSemaTypes, eSemaProcs, and eSemaModules
// will be emitted, they are also required to be valid tree_t objects
// any custom slots can contain any data, but they will not be emitted

CT_TREE_API tree_t *tree_module_root(logger_t *reports, tree_cookie_t *cookie, const node_t *node, const char *name, size_t decls, const size_t *sizes, arena_t *arena);

/**
 * @brief create a new module
 *
 * @param parent the parent module
 * @param node location of the module
 * @param name the name of the module
 * @param decls the number of declaration categories in the module
 * @param sizes the size of each declaration category
 * @return the module
 */
CT_TREE_API tree_t *tree_module(tree_t *parent, const node_t *node, const char *name, size_t decls, const size_t *sizes);

/**
 * @brief recursively search for a declaration in a module
 *
 * @param self the module
 * @param tag the declaration category
 * @param name the name of the declaration
 * @return the declaration or NULL if it does not exist
 */
CT_TREE_API void *tree_module_get(tree_t *self, size_t tag, const char *name);

/**
 * @brief set a declaration in the current module
 *
 * @note if the declaration already exists it will not be replaced
 *
 * @param self the module
 * @param tag the declaration category
 * @param name the name of the declaration
 * @param value the value of the declaration
 * @return a previous declaration or NULL if it did not exist
 */
CT_TREE_API void *tree_module_set(tree_t *self, size_t tag, const char *name, void *value);

CT_TREE_API map_t *tree_module_tag(const tree_t *self, size_t tag);

/**
 * @brief return a resolution cookie
 *
 * @param sema the module
 * @return the cookie
 */
CT_TREE_API tree_cookie_t *tree_get_cookie(tree_t *sema);

/// @}

END_API
