#include "codegen/codegen.h"

#include "base/panic.h"
#include "io/io.h"
#include "memory/arena.h"

#include "std/map.h"
#include "std/str.h"
#include "std/typed/vector.h"
#include "std/vector.h"

typedef struct cg_field_t
{
    const char *name;
    const char *type;
} cg_field_t;

typedef struct cg_class_t
{
    cg_context_t *ctx;

    const char *name;
    cg_class_t *super;

    typevec_t *fields;
} cg_class_t;

typedef struct cg_context_t
{
    arena_t *arena;

    const char *prefix;

    cg_class_t root;
    vector_t *classes;
} cg_context_t;

static void init_cg_class(cg_class_t *cls, cg_context_t *ctx, const char *name, cg_class_t *super)
{
    cls->ctx = ctx;
    cls->name = name;
    cls->super = super;
    cls->fields = typevec_new(sizeof(cg_field_t), 2, ctx->arena);

    vector_push(&ctx->classes, cls);
}

cg_context_t *cg_context_new(const char *prefix, arena_t *arena)
{
    CTASSERT(arena != NULL);

    cg_context_t *ctx = ARENA_MALLOC(arena, sizeof(cg_context_t), "cg_context_t", NULL);

    ctx->arena = arena;
    ctx->prefix = prefix;
    ctx->classes = vector_new(32);
    init_cg_class(&ctx->root, ctx, "root", NULL);

    return ctx;
}

cg_class_t *cg_root_class(cg_context_t *ctx)
{
    CTASSERT(ctx != NULL);

    return &ctx->root;
}

cg_class_t *cg_class_new(const char *name, cg_class_t *super)
{
    CTASSERT(name != NULL);
    CTASSERT(super != NULL);

    cg_context_t *ctx = super->ctx;

    cg_class_t *cls = ARENA_MALLOC(ctx->arena, sizeof(cg_class_t), name, super);

    init_cg_class(cls, ctx, name, super);

    return cls;
}

void cg_class_add_basic_field(cg_class_t *class, const char *name, const char *type)
{
    CTASSERT(class != NULL);
    CTASSERT(name != NULL);
    CTASSERT(type != NULL);

    cg_field_t field = {
        .name = name,
        .type = type,
    };
    typevec_push(class->fields, &field);
}

void cg_class_add_class_field(cg_class_t *class, const char *name, const cg_class_t *type)
{
    CTASSERT(class != NULL);
    CTASSERT(name != NULL);
    CTASSERT(type != NULL);

    cg_field_t field = {
        .name = name,
        .type = format("%s_t*", class->ctx->prefix),
    };

    typevec_push(class->fields, &field);
}

static const char *const kWarningHeader =
    "// This file is generated by the codegen library.\n"
    "// Do not edit manually, edit the codegen script instead.\n\n"
    "// clang-format off\n\n";

static void add_child_class(map_t *tree, cg_class_t *parent, cg_class_t *child)
{
    CTASSERT(tree != NULL);
    CTASSERT(parent != NULL);
    CTASSERT(child != NULL);

    vector_t *children = map_get_ptr(tree, parent);
    if (children == NULL)
    {
        children = vector_new(2);
    }

    vector_push(&children, child);
    map_set_ptr(tree, parent, children);
}

static void collect_class_tree(map_t *tree, cg_class_t *cls)
{
    CTASSERT(tree != NULL);
    CTASSERT(cls != NULL);

    if (cls->super != NULL)
    {
        add_child_class(tree, cls->super, cls);
    }
}

typedef struct cg_emit_t
{
    io_t *io;
    cg_context_t *ctx;
    size_t depth;

    map_t *tree;
} cg_emit_t;

static void emit_indent(cg_emit_t *ctx)
{
    CTASSERT(ctx != NULL);
    ctx->depth += 1;
}

static void emit_unindent(cg_emit_t *ctx)
{
    CTASSERT(ctx != NULL);
    ctx->depth -= 1;
}

CT_PRINTF(2, 3)
static void emit_printf(cg_emit_t *ctx, const char *fmt, ...)
{
    CTASSERT(ctx != NULL);
    CTASSERT(fmt != NULL);

    char *pad = str_repeat("  ", ctx->depth);
    io_printf(ctx->io, "%s", pad);

    va_list args;
    va_start(args, fmt);
    io_vprintf(ctx->io, fmt, args);

    va_end(args);

    io_printf(ctx->io, "\n");
}

static cg_emit_t build_emit(cg_context_t *ctx, io_t *io)
{
    // build the tree
    size_t len = vector_len(ctx->classes);
    map_t *tree = map_optimal(len);

    for (size_t i = 0; i < len; i++)
    {
        cg_class_t *cls = vector_get(ctx->classes, i);
        collect_class_tree(tree, cls);
    }

    cg_emit_t emit = {
        .io = io,
        .ctx = ctx,
        .depth = 0,
        .tree = tree,
    };

    return emit;
}

static void print_enum_case(cg_emit_t *emit, const cg_class_t *cls)
{
    CTASSERT(emit != NULL);
    CTASSERT(cls != NULL);

    emit_printf(emit, "%s_%s,", emit->ctx->prefix, cls->name);

    vector_t *children = map_get_ptr(emit->tree, cls);
    if (children == NULL) return;

    emit_indent(emit);

    size_t count = vector_len(children);
    for (size_t i = 0; i < count; i++)
    {
        cg_class_t *child = vector_get(children, i);
        print_enum_case(emit, child);
    }

    emit_unindent(emit);
}

static void print_enum(cg_emit_t *emit)
{
    cg_context_t *ctx = emit->ctx;

    emit_printf(emit, "typedef enum %s_type_t {", ctx->prefix);
    emit_indent(emit);

    print_enum_case(emit, &ctx->root);

    emit_unindent(emit);
    emit_printf(emit, "} %s_type_t;", ctx->prefix);
}

static void emit_struct_part(cg_emit_t *ctx, cg_class_t *cls);

static void emit_struct_body(cg_emit_t *ctx, typevec_t *fields, vector_t *children)
{
    size_t field_count = typevec_len(fields);
    for (size_t i = 0; i < field_count; i++)
    {
        const cg_field_t *field = typevec_offset(fields, i);
        emit_printf(ctx, "%s %s;", field->type, field->name);
    }

    // emit children
    if (children != NULL)
    {
        emit_printf(ctx, "union {");

        emit_indent(ctx);

        size_t len = vector_len(children);
        for (size_t i = 0; i < len; i++)
        {
            cg_class_t *child = vector_get(children, i);
            emit_struct_part(ctx, child);

            if (i != len - 1)
            {
                emit_printf(ctx, "");
            }
        }

        emit_unindent(ctx);

        emit_printf(ctx, "};");
    }
}

static void emit_struct_part(cg_emit_t *ctx, cg_class_t *cls)
{
    CTASSERT(ctx != NULL);
    CTASSERT(cls != NULL);

    emit_printf(ctx, "// %s", cls->name);

    vector_t *children = map_get_ptr(ctx->tree, cls);

    // emit fields
    size_t field_count = typevec_len(cls->fields);
    bool needs_struct = field_count > 1 || (field_count == 1 && children != NULL);

    if (needs_struct)
    {
        emit_printf(ctx, "struct {");
        emit_indent(ctx);
    }

    emit_struct_body(ctx, cls->fields, children);

    if (needs_struct)
    {
        emit_unindent(ctx);
        emit_printf(ctx, "};");
    }
}

static void print_struct(cg_emit_t *emit)
{
    cg_context_t *ctx = emit->ctx;
    emit_printf(emit, "typedef struct %s_t {", ctx->prefix);

    emit_indent(emit);

    cg_class_t *root = &ctx->root;
    vector_t *children = map_get_ptr(emit->tree, root);

    emit_struct_body(emit, root->fields, children);

    emit_unindent(emit);

    emit_printf(emit, "} %s_t;", ctx->prefix);
}

void cg_emit_header(cg_context_t *ctx, io_t *io)
{
    CTASSERT(ctx != NULL);
    CTASSERT(io != NULL);

    io_printf(io, "#pragma once\n\n");
    io_printf(io, "%s", kWarningHeader);

    cg_emit_t emit = build_emit(ctx, io);

    print_enum(&emit);

    io_printf(io, "\n");

    print_struct(&emit);

    io_printf(io, "\n// clang-format on\n");
}
