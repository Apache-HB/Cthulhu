type LPSTR = str;
type DWORD = uint;
type BOOL = int;

struct Arena {
    name: str;
    alloc: def(*Arena, usize) -> opaque;
    release: def(*Arena, opaque) -> void;
}

struct System {
    name: str;
}

@extern("printf")
def printf(fmt: str, args: ...): int;

@extern("malloc")
def libcAlloc(size: usize): opaque;

@extern("free")
def libcRelease(ptr: opaque);

@extern("GetComputerNameA")
def win32GetComputerNameA(name: str, size: *DWORD): BOOL;

def defaultAlloc(mem: *Arena, size: usize): opaque {
    printf("[%s] alloc %zu\n", mem->name, size);
    return libcAlloc(size);
}

def defaultRelease(mem: *Arena, ptr: opaque) {
    printf("[%s] release %p\n", mem->name, ptr);
    libcRelease(ptr);
}

def defaultArena(name: str): Arena {
    var mem: Arena = noinit;
    mem.name = name;
    mem.alloc = defaultAlloc;
    mem.release = defaultRelease;
    return mem;
}

def arenaAlloc(mem: *Arena, size: usize): opaque {
    return mem->alloc(mem, size);
}

def arenaRelease(mem: *Arena, ptr: opaque) {
    mem->release(mem, ptr);
}

def getComputerName(mem: *Arena): str {
    var size: DWORD = 256u;
    var name: str = arenaAlloc(mem, size);
    if win32GetComputerNameA(name, &size) == 0 {
        return "Unknown";
    }

    return name;
}

export def newSystem(mem: *Arena): System {
    var result: System = noinit;
    result.name = getComputerName(mem);
    return result;
}

export def getSystemName(system: System): str = system.name;

@entry(cli)
def main {
    var mem = defaultArena("libc");

    const system = newSystem(&mem);
    printf("System name: %s\n", getSystemName(system));
}
